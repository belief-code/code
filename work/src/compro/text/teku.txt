    GCD　ユークリッド

    素数　最小の素因数の上限はsqrt(n)   

    DP使う問題などで特に注意すべきだがa,bを例えば敷き詰めるときに何番目にbが来る。みたいなのはやめたほうが良い。
1番目がaかbか、からn番目がaかbかって感じで一つずつ進めていくほうが良い。
この利点はなんといっても実装時に考える必要のあるものを減らせる。ある種一般化

    配列の後ろの方から操作する系の問題はミスしやすくなるからreverseで一回左右反転させてとく

    最小構成要素を一つずつ増やしていく感じでDPやれば意外にだいたい行ける

    状態によってその後の状態のパターンがいくつか考えられる場合は木のようなものを
想定すると枝が沢山でているような遷移図をかける。
このような場合は3パターン典型的な解き方がある。
1:全ての状態が入れるような箱を用意して順番にDP
2:遷移図を想定しながら(状態ごとに取れる選択肢が限られているなら?)BFS(queueを用意するとやりやすい)
3:遷移図を想定しながらDFS→再帰関数を使ってやるっぽい。行き詰まるまでとりあえず試行していって一個前を変えるってのを繰り返す。
↓再帰関数の作り方
状態を特定できるパラメーターを引数とする関数を設定する
最初に特定の状態に到達したかどうかの判定式を書く。
次にその状態で取れる状態遷移をとりあえず一個一個するような文を書く
最後に次の遷移状態を指定してtrueが帰ってきたらtrueを返すようにする。
こうすることでどこかで最初の判定式でtrueが帰ってきたときに一番最初のところまでtrueが帰ってくる。
↑この流れの中で辿っていく状態が深さ優先探索的になる。

BFSで自然に解けるものはDFSでも制限かければ多分解ける。
逆も同じ。問題によっては深さ方向幅方向どちらにも制限が必要な場合も？
DFSで全探索をするプログラムを書いた後にDPにできそうなときはメモ探索するといい

