        グラフ(グラフ理論)

    1.概要
頂点(vertex)の有限集合V={v1,v2,...,vn}
辺(edge)の有限集合E={e1,e2,...,em}
の組として定義され、G=(V,E)と表されるもの。
-viとvjがつながっている時その状態を隣接している(adjacent)といい、それぞれを端点(end)と呼ぶ。

グラフの各辺について向きを考えずに(vi,vj)と(vj,vi)を同一視出来る時Gを無向グラフといい、区別する時有向グラフと呼ぶ。
-路:グラフG上の二蝶点u,vについて隣接する頂点を辿って到達できる時その経路をu-v路と呼びそれぞれ始点、終点と呼ぶ。
-パス:路の内同じ頂点を二度通らないもの。
-サイクル(閉路):路の内始点と終点が等しいもの。
-連結:グラフGの任意の二頂点u,vに対してu-vパスまたはv-uパスが存在する時Gは連結であるという。
    無向グラフである場合は片方のパスが存在することはもう片方も存在することと当然同義
-強連結:有向グラフGの任意の二頂点u,vに対してu-vパスもv-uパスも存在する時、Gは強連結であるという。

    2.計算機上でのグラフの表し方
大きく分けて
-隣接リスト表現
-隣接行列表現
の2つがあるが、多くのグラフアルゴリズムは隣接リスト形式の方が効率よく実現可能なことが多い。
    
    隣接リストの実装
グラフの頂点集合を一般性を失わずにV=(0,1,...,N-1)とする。
拡張点vに対して、辺(v,v')が存在するような頂点v'をリストアップする。
なおこの作業は無向グラフ有向グラフ関係なく実施可能。
これらの情報をそのまま可変長配列などに格納する。

以下にIOの例
#include <iostream>
#include<vector>
using namespace std;
using Graph=vector<vector<int>>;//グラフ型

int main(){
    //頂点数と辺数
    int N,M;cin>>N>>M;

    //グラフ
    Graph G(N);
    for (int i=0;i<M;i++){
        int a,b;
        cin>>a>>b;
        G[a].push_back(b);

        //無向グラフの場合は以下を追加
        //G[b].push_back(a);
    }
}


        3.深さ優先探索(DFS)と幅優先探索(BFS)

    3-1.グラフ探索の一般的なフレームワーク
グラフ上の頂点sから出発して到達できる頂点を全て探索する方法について一般的なフレームワークを検討する。
以下の2つのデータを管理する
-seen:その頂点を検知済みかどうかを表す配列
-todo:検知したがまだ到達済みでない頂点の集合
この時グラフ探索は、深さ優先でも幅優先でも、一般的に下のような擬似コードで記述できる。
なおここでグラフ頂点vに隣接している頂点集合をT(v)と表している。
1.seen全体をfalseに初期化して、todoを空にする
2.seen[s]=trueとして、todoにsを追加する
3.todoが空になるまで以下を繰り返す:
4.  todoから一つ頂点を取り出してvとする
5.  t(v)の各要素wに対して、
6.      seen[w]=trueであったならば、何もしない
7.      そうでなかったら、seen[w]=trueとして、todoにwを追加する。
ここで4行目の保留頂点集合todoから頂点vを取り出す作業をどのようなポリシーに則って行うかでDFS,BFSが分岐する。
また、例えばsを初期地点としてsからa,b,c、aからd,eに繋がっているとして上記の手順を踏んで見ると
seen[s]=trueとして、todoにsを追加
    todoからsを削除してseenにa,b,cが追加される
    todoからaを削除してseenにd,eが追加される。
この時todoの中身はb,c,d,eになっているが
-最後に追加したd,eを優先的に読む
-最初に追加したb,cを優先的に読む
という二通りの指針が存在することになるが、
前者はLIFO(Last-In First-Out)ということで保留頂点集合todoをスタックにすることで実現出来る。
またtodoにスタックを用いたときのグラフ探索を深さ優先探索(DFS)と呼ぶ。
後者はFIFO(First-In-First-Out)ということで、保留頂点集合todoをキューにすることで実現できる。
この時のグラフ探索を幅優先探索(BFS)と呼ぶ。

    3-2.木の場合の探索順
DFSとBFSの動きについてより詳細に見ていく。
ここでは一般のグラフよりわかりやすい木の場合を考え両探索の違いを明らかにする。

まず木とは
-サイクルを持たない
-連結である
この2つを満たすようなグラフのこと。
木に対し、特定の一つの頂点を特別扱いして根(root)と呼ぶことがある。
そのような特定の根を持つ木のことを根付き木(rooted tree)と呼ぶ。
木はグラフの一種なので前節で説明したDFS,BFSが可能。
この時根を探索の始点となる頂点とするのが自然なのでそうする。
この時の探索順を想像するとDFS,BFSの違いがわかりやすい。

    3-3.DFSの再帰関数を用いた実装
ここまでDFSのとして
-seen:その頂点を検知済みかどうかを表す配列
-todo:検知したがまだ訪問済みでない頂点の集合(スタック)
というデータを用いた説明を行ってきた。しかしDFSのは再帰関数と相性がよく、
スタックを用いずにその部分を再帰関数によって実装する。
以下に実装例

#include<iostream>
#include<vector>
using namespace std;
using Graph=vector<vector<int>>;

//深さ優先探索(再帰関数内では上で行ってきた訪問時の手続きを行う。)
vector<bool> seen;
void dfs(const Graph &G, int v){
    seen[v]=true;//vを訪問済みにする

    //vから行ける各頂点next_vについて
    for(auto next_v:G[v]){
        if(seen[next_v])continue; //next_vが探索済みだったらスルー
        dfs(G,next_v);//再帰的に探索
    }
}

int main(){
    //頂点数を辺数
    int N,M;cin>>N>>M;

    //グラフ入力受取(ここでは無向グラフを想定)
    Graph G(N);
    for(int i=0;i<M;i++){
        int a,b;
        cin>>a>>b;
        G[a].push_back(b);
        G[b].push_back(a);
    }

    //頂点0をスタートとした探索
    seen.assign(N,false);//全頂点を｢未訪問｣に初期化
    dfs(G,0); 
}

    3-4.DFSの探索順序についての詳細
DFSを用いた応用的アルゴリズムである「トポロジカルソート」や「強連結成分分解」について学ぶ時必要になる
行きがけ順、帰りがけ順、タイムスタンプの3つの概念について以下に書く。
まず行きがけ順とは初めて訪問した頂点の順序で順位をつけたもの。
帰りがけ順とは最後に訪問した頂点の順序で順位をつけたもの。つまり最初の末端が0番目になる。
以下に拡張店の行きがけ順、帰りがけ順を求めるコードを記す。

#include<iostream>
#include<vector>
using namespace std;
using Graph=vector<vector<int>>;


vector<bool> seen;
vector<int> first_order;//行きがけ順
vector<int> last_order;//帰りがけ順

void dfs(const Graph &G,int v,int& first_ptr,int& last_ptr){
    //行きがけ順をインクリメントしながらメモ
    first_order[v]=first_ptr++;

    seen[v]=true;
    for(auto next_v:G[v]){
        if(seen[next_v])continue;
        dfs(G,next_v,first_ptr,last_ptr);
    }

    //帰りがけ順をインクリメントしながらメモ
    last_order[v]=last_ptr++;
}


int main(){
    //頂点数と辺数
    int N,M;cin>>N>>M;

    //グラフ入力受取(ここでは無向グラフを想定)
    Graph G(N);
    for(int i=0;i<M;i++){
        int a,b;
        cin>>a>>b;
        G[a].push_back(b);
        G[b].push_back(a);
    }

    //頂点0をスタートとした探索
    seen.assign(N,false);//全頂点を｢未訪問｣に初期化
    first_order.resize(N);
    last_order.resize(N);
    int first_ptr=0,last_ptr=0;
    dfs(G,0,first_ptr,last_ptr);

    //各頂点vの行きがけ順、帰りがけ順を出力
    for(int v=0;v<N;v++)
        cout<<v<<": "<<first_order[v]<<", "<<last_order[v]<<endl;
}

行きがけ順と帰りがけ順とを統一する概念としてタイムスタンプがある。
これは各頂点vに対し、最初に発見した段階と、vの子孫たちも含めて探索を終えた段階とを表すもの。
前者を小ささ順に並べて順番に0から番号を振っていけば行きがけ順と同じものになる。
後者に関しても同じことが出来る。復元可能な上に情報量が多いので基本こっちで実装してもいいのかもしれない。

実際に実装する際には上で分けていたfirst_ptrとlast_ptrを統一して一つの辺数ptrにすれば良い。
void dfs(const Graph &G,int v,int& ptr){
    first_order[v]=ptr++;

    seen[v]=true;
    for(auto next_v:G[v]){
        if(seen[next_v])continue;
        dfs(G,next_v,ptr);
    }

    last_order[v]=ptr++;
}
タイムスタンプは強連結成分分解やオイラーツアーを用いた木上クエリ処理について考える時に重要な概念になる。

    3-5.DFSの計算量
頂点数をN辺数をMとしてO(N+M)


        4.グラフ上の様々な例題

参考資料:https://qiita.com/drken/items/4a7869c5e304883f539b