    構造体
    宣言・初期化
struct 構造体名{
    type メンバ変数名;
    type メンバ関数名(){}
};//←セミコロンが必要

int main(){
    構造体名 オブジェクト名;
}

特定の値で初期化したい場合は以下のようにする。
構造体名 オブジェクト名 = {メンバ変数1の値, メンバ変数2の値, メンバ変数3の値, ...(必要な分だけ書く)};
 
 
  例
#include <bits/stdc++.h>
using namespace std;
 
struct MyPair {
  int x;
  string y;
  // メンバ関数
  void print() {
    // 直接x, yにアクセスできる
    cout << "x = " << x << endl;
    cout << "y = " << y << endl;
  }
};
 
int main() {
  MyPair p = { 12345, "Hello" };
  p.print();  // オブジェクト`p`の`print`を呼び出す
 
  MyPair q = { 67890, "APG4b" };
  q.print();  // オブジェクト`q`の`print`を呼び出す
}




    アクセス
オブジェクト名.メンバ変数;
オブジェクト名.メンバ関数;

    コンストラクタ
コンストラクタとはオブジェクトを作成するときに行われるように構造体内で
設定できる処理である。
struct MyPair {
  int x;
  string y;
  // コンストラクタ
  MyPair() {
    cout << "constructor called" << endl;
  }
};

コンストラクタはメンバ関数と同じように引数を取ることが出来る。
struct 構造体名 {
  // コンストラクタ
  構造体名(引数1の型 引数1の名前, 引数2の型 引数2の名前, ...) {
    // コンストラクタの内容
  }
};
コンストラクタが引数を取る場合、次のようにオブジェクトの宣言時にコンストラクタの
引数を渡す必要がある。
構造体名 オブジェクト名(引数1, 引数2, 引数3, ...);


    演算子のオーバーロード
オブジェクトに演算が行われるときの振る舞いをプログラムできる。
例えばオブジェクト+aみたいなことが行われたときにどのように振る舞うか決めたいときは
struct 構造体名 {
  返り値の型 operator+(引数の型 引数) {
    // 処理内容
  }
};
このようにする。
とりあえずオーバーロードについてはoperator演算子という形が出てきたら
オーバーロードということを思い出して都度ググればいい。
上の演算子のオーバーロードは構造体内でやったからこういう書き方になってるけど
構造体の定義内でなくても出来て、その場合は引数をちゃんと2つ取ること。