    この中に入れると入れたものの種類が分かるようなデータ構造。
値の重複を許さないsetの他に許さないmultisetも使える。
基本的な働きは
    重複するようなものは省く。(multisetの場合は省かない)
    常に昇順にソートされている。
    大体の操作がO(LogN)で実装されている。
大体この3つ。おおよそvectorと同じ様な感じで操作できる。
(参考URL:https://cpprefjp.github.io/reference/set/set.html)

    宣言
set<type> S;
multiset<type> MS;

    要素の追加
S.insert(x);

    要素の削除
S.erase(x);
    集合Sから要素xを削除する。(MSの場合は要素xを全て削除)
S.erase(y);
    集合Sからイテレーターyの要素を削除する。(MSの場合でも一つだけ削除できる)

    その他の操作
S.lower_bound(x);
    集合Sからx以上である最小の要素を指すイテレーターを返す。
        これはこの構造である利点を結構活用できてる。
S.clear();
    集合Sを空にする。
S.find(x);
    集合Sから要素xのイテレーターを返す。
    これと同じことをvectorでやるとすると
    sort(v.begin(),v.end());
    binary_search(v.begin,v.end,x);
    となるが前者がO(nlogn)後者がO(logn)となりO(nlogn)となる。
    しかし、vectorの場合は入力がpbでO(1)だがsetだとinsertでO(logn)なので
    結局変わらないような気がする。なんなら入力がソートされている前提なら
    vectorのほうが早い。