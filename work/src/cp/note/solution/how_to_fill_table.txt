テーブルを埋める方法について
　あらゆる問題について、その問題を分解していくと、テーブルを埋める必要が出てくることがある。
テーブルの埋め方については、
-テーブル上の要素同士の関係
-テーブルの各要素、また全体が表すもの
の2つを明らかにすることで、効率良く解くことが出来る。



1.テーブル上の要素(のグループ)の関係の3パターン

1.1.テーブルの要素(のグループ)に親子関係があるもの
　これは操作系の問題から派生して作られることが多く、基本的には各要素について親要素のようなものが存在して、
親要素からテーブルを満たしていくことによって計算量を削減できることが殆ど。
これはテーブル上での親と子の関係を有向辺で表した時に、DAG順に処理を行うことに相当する。
よって、

1.2.テーブルの要素(のグループ)に親子関係がないもの

1.2.1.テーブルの要素を何らかの特徴でグループ分けできる場合
　テーブルの要素を何らかの特徴でグループ分け出来る時は、そのグループごとに計算して埋めていくことで、
計算量削減出来る場合がある。
　それでも足りない場合には、そこに含まれる各テーブル自体に親子関係を持つようなメタテーブルを作ることで計算量改善になることがある。
ここで計算量が削減されるかどうかは天下り的評価をするしかないことが多く、正当性を持ってテーブルを作るのは結構難しかったりする。
(ワーシャルフロイド法は二次元テーブルを各要素とする親子関係のある1次元メタテーブル)

1.2.2.テーブルの要素を何らかの特徴でグループ分け出来ない場合
　これには
-効率良く各要素を計算する
-メタテーブルを用意する
の二通りの解き方がある。

1.3.テーブルの要素(のグループ)にある親子関係を有向辺で表した時にサイクルがあるような場合
　サイクル上の要素(のグループ)を一つ計算して、そこからサイクル上の要素(のグループ)を埋めると良い。
この時に、適当にやると、サイクル上の要素(のグループ)一つ一つを計算してしまうので注意する。




2.テーブルの要素、全体が表すもののパターン

2.1.部分問題の解
　これは操作系問題から派生して作られることが多く、要素同士に親子関係があることで、各要素を少ない計算量で満たすことが
可能な場合が殆ど(というかそのようになるようにテーブルを作るべき)。

2.2.制約の違う問題の解
　これも操作系問題から派生して作られることが多いが、要素同士に明示的な親子関係があることは少ない上に、
テーブルが先に与えられる場合が多い。
-メタテーブルを作る
-特徴でグループ分けしてグループごとに埋める
などで解決可能なことが多い。

2.3.集合の要素
　これは構成系の問題から派生して作られることが多く、構成されたものの中にあるものを1,ないものを0、
などとして、構成の集合を表す。




3.テーブルの最適化(圧縮)
　考慮しているテーブルについて、そのテーブルを、各要素テーブルを展開したメタテーブルと見ることが出来る時、
要素テーブルを一つだけ持っておき、それを更新するような方法に組み替えることで、親テーブルから小テーブルでの
変更箇所が少ない場合などにはコピーを行う時間を削減でき、結果としてかなり時間を短縮出来る場合がある。
　特に、展開メタテーブルが3次元の場合には、要素テーブルが2次元となって、3次元では使えなかったデータ構造を
導入可能になり、それ故計算量を簡単に下げることが出来るようになる。などが良く起こる。
3次元では見えにくかった構造上の利点も2次元に落とすことにより見えやすくなる。
　逆に言えば更新手続きをテーブル全体に行うようなアルゴリズムは背景にメタテーブルの存在があるので、
それについて考えるとこころをつかみやすくなる。


4.テーブルの埋め方
　テーブルの埋め方には、大きく分けて
-各要素ごとに埋めていく
-グループごとに埋めていく
-親グループから順番に埋めていく
-全ての要素を何回か更新する(親テーブルから順番に埋めていくこととほぼ同義)
の4パターンがある。

4.1.各要素ごとに埋めていく
　出来るだけ計算量を削減しても間に合わない場合には、他の3パターンの埋め方を検討すべき(メタテーブルの導入も視野にいれるべき)

4.1.2.テーブルの各要素が集合の要素を表す場合
　0,1に埋める際に、
-最初全てを0として埋めていく
-最初全てを1として埋めていく
-最初全てを-1として埋めていく
の3通りの埋め方があり、これらはデータ上はそう違いがないように思えるが、実際の手順の意味を考えると
結構差がある上に、考えやすさもかなり問題によっては異なる。

4.1.2.1.最初全てを0として埋めていく場合
　概要:無から構成していくようなきもち。なんらかの要素が何かの「上位互換か判定するのが簡単な場合」に強い。
あとは、出来るだけ詰め込む時にもつよい。
　この方針を選ぶ際には、例えば総和が大きくなるように、であれば
-大きいものから貪欲に制約を満たすように入れていく(これが最善になるかは問題による)
-適当な順番で要素を見ていって、それがある制約を満たす上で「他の選択肢の上位互換的選択であるなら」1で上書きする

4.1.2.2.最初全てを1として埋めていく場合
　概要:全てを集合に入れた時に制約を満たすような場合、且つなんらかの要素が何かの「下位互換か判定するのが簡単な場合」に強い。
あとは、出来るだけ減らす時にも強い
　この方針を選ぶ際には、例えば総和が小さくなるように、であれば
-大きいものから貪欲に制約を満たすように消していく(これが最善になるかは問題による)
-適当な順番で要素を見ていって、それがある制約を満たす上で「他の選択肢の下位互換的選択であるなら」0で上書きする

4.1.2.3.最初全てを-1として埋めていく場合
　概要:やったことないからわからないけど、こうしたほうがいい場合があるのかすらかなり疑問がある。




4.2.グループごとに埋めていく
　ある特徴を持つもの同士でそれらを計算する時にお互いの情報があると計算量削減になる場合などは、
グループ全体を一度に計算すると計算量が削減出来ることがある。(最短経路問題における始点が同じものをまとめることで
ダイクストラ法が丸々使える場合など)

4.3.親グループから順番に埋めていく
　操作系問題に関与するテーブルである場合には、操作手順数の少ない部分問題の解を表すものから順番に埋めていくことで、
その次に操作手順数の少ない部分問題の解を少ない計算量で求められることが多いので(枝刈り的背景による)、そのように埋めていくと良い。

4.4.全ての要素を何回か更新する
　このような埋める手順を取る場合には、メタテーブルからの圧縮手順を踏んでいるはずなので、圧縮の意図が
-メモリ削減
-コピー手順削減による計算量削減
-データ構造の導入による計算量削減
この3つのどれなのか、まず明確にする。
この内、1,2番目である場合には、そのままやるといい(2番めの場合には単調増加列にしておくと二分探索で更新箇所を割り出せる場合などがあることに注意)。
3番目である場合には、
-二分ヒープ(単調増加列もこれ)
-赤黒木
-セグメント木
-BIT
などのデータ構造が考えられるので、どれを使うといいか考えるといい。


