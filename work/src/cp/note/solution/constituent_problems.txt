構成系の問題に対するアプローチ
0.構成系問題とは
　-Aを用いてBを満たすようにCを構成したときのDを求めよ
といった問題。
1.構成系問題での最悪計算量の下げ方
典型的なものから順に

-制約を緩めた問題から順に解いていく(部分構造最適性のある場合が殆ど)
例:(左からi個目までの最善構成を考えiを増やしていく)https://atcoder.jp/contests/abc135.tasks/abc134_e
-制約を満たすようなものを構成できることが保証される(簡単に列挙できる)最小の候補集合について、
一つ一つ構成に必要か判定する
例:https://atcoder.jp/contests/abc075.tasks/arc083_b
-何かの更新を何回か行うと何らかの要因でうまくいく

などがある。(前者で最悪計算量が下がるような場合には緩める制約が対象の個数などの場合には枝刈り的な背景で下がっている場合が殆ど)

2.問題全体、制約、求めるもの、の読み替え
　一般化して
Aを用いてBを満たすようにCを構成したときのDを求めよ
という問題として考える。
A:構成要素
B:制約
C:A,Bを満たす構成
D:Cについてのなにか(C自体とか、Cの個数とか、Cの内の何かとか)

2.3.求めるものの読み替え

2.3.1.Cの内の一つを構成せよ。と読み替える
　Cが複数個構成可能な場合に、DがCをの共通の特徴の場合には、全て構成する必要はなく、最も構成が簡単なものを一つ
構成してしまえば良いことがある。このような場合には、A,Bを満たすCをとりあえず一つ作って、それについてのDを返せば良い。


3.典型的な構造の分割方法
　森全体を作る場合には、森全体として構成するよりも木ごとに構成していくほうがいいこともある。
このようにどの部分で構造を分割のがよいことが多いか紹介する



4.Cの種類と有効なアプローチの対応

4.1.一つの集合
　概要:ただ一つ集合を構成するだけでいい。要素が入っているか入っていないかをビットで表すテーブルを一つ持ち、
そのテーブルを一つ一つ更新していくだけで一応解ける。
　アプローチ:
-空集合に候補を良い順番で見ていき必要な要素だけを入れて構成する
-候補が少ない場合には、全ての候補を含むテーブルを用意してテーブルを埋める問題として処理する。(how_to_fill_table:4.1.2.参照)
例:https://atcoder.jp/contests/abc074/tasks/arc083_b

4.2.複数の集合
　概要:複数の集合を構成する場合
　アプローチ:
-良い順番で一つ一つに新しい集合を作りそこに入れる、今までに出来た集合に割り振る、の二択をして処理していく。
-操作問題(色塗り問題)として処理する

4.3.一つの順序集合
　概要:操作手順を作る問題(操作問題全般)や二点間最短経路問題はここに入るとも言える。このことからも構成系問題の幅の広さがわかる。
　アプローチ:
-部分問題を解いて行く(順序の若いものまでの部分問題を解く。みたいなことをすると遷移出来ることが多い)
-操作問題として処理する


4.4.複数の順序集合
　概要:例えば数列Aを複数の単調増加列に分解する問題などはここに含まれる。
　アプローチ:
-一つ一つ順番に見ていきそこまでに出来た集合のどれかに割り振る・新しく集合を作る、の二択をして処理していく。
例:https://atcoder.jp/contests/abc134/tasks/abc134_e





//以下は全部書き直したほうがいい
5.問題の切り口と問題の種類の対応(これは一回書き直したほうがいい)

5.1.無から何らかの順序で構成していく

5.1.1.Cが複数個存在して、その全てを構成する必要がある場合
　概要:Aの中からAの要素を適当に順序付けして(普通は最初からなんらかの順序付けがなされているのでそのまま使う。
この順序を意味のある順序に組み替えることで貪欲な判定が可能になることもあるかも)無から順番にBを満たすように
作り上げていく。
　選択:そこまでで作った構成のどこに今見ている要素を付けるのか考える。
この時、確実にA,Bを今後満たせないものだけ切り捨て、次に遷移する(枝刈り的手法)


5.1.2.A,Bを満たすCをどれでも一つ構成できれば事足りる場合
　概要:Aの中からAの要素を適当に順序付けして(普通は最初からなんらかの順序付けがなされているのでそのまま使う。
この順序を意味のある順序に組み替えることで貪欲な判定が可能になることもあるかも)無から順番にBを満たすように、
作り上げていく。
　選択:そこまでで作った構成のどこに今見ている要素を付けるのか考える。この時、一概に良い選択(要請によって判断される)
があるのなら一概に良い選択をし続け遷移していくだけでいい。そうでない場合には、テーブルを用意して上位互換的選択肢のみ
保存して次に渡しながら遷移する。
　例:一意に良い構成方法が存在する場合:https://atcoder.jp/contests/abc135.tasks/abc134_e

5.1.3.A,Bを満たすCの中でDなものを構成すれば良い場合(Dは最小なものや最大のものなどを表すことが多い)
　概要:Aの中からAの要素を適当に順序付けして(普通は最初からなんらかの順序付けがなされているのでそのまま使う。
この順序を意味のある順序に組み替えることで貪欲な判定が可能になることもあるかも)


5.2.確実に制約を満たすような場合から削っていく(彫刻的構成)
　概要:例えばダビデ像などは、足の裏から順番に積み立てるように作らずに、ダビデ像を包含可能な
石の塊を持ってきて、そこからダビデ像の内部に相当するかどうかを判定しながら削る・削らないの判定を行っていっても
構成可能である。またこのように複数回の簡単な判定を行うような手順は計算機の得意とする方法であるので正当性がある。
　可能対象:例えばダビデ像の例で言えば分割単位が小さすぎる、つまり判定対象(要素の候補)が多すぎる場合には時間がかかりすぎる。
また少なかったとしても一つ一つの判定に時間がかかる場合にはこれも難しい。
実際にこの方法が適用出来るような問題は、結構限られる。

5.2.1.Cの内最も


6.ここまででテーブルを埋める問題に帰着されなかった場合の対処法




