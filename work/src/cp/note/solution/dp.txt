以下は全て、貰うDP、メモ化再帰主軸に考える。

0.0.動的計画法で問題が解ける仕組み、計算量が落ちる仕組み
　動的計画法が行っているのって、結局枝刈りのようなものなのでは？
常にベターな選択肢を一つ選ぶことは、消したパターンの遷移先を考えないようにしているのと同じなわけだから、
この考えから、DPの各遷移ごとの要素数はその状態で、上位互換が存在する遷移を全て刈り取ったときの最小の要素数になるようにするのが最善で、
そのように出来る状態の表し方が最善の表し方といえるのでは？
0.1.動的計画法の種類
　動的計画法には、
-時間と特徴で遷移するDP(各操作段階で、その特徴をもつ中でのベスト(その特徴を持つ他の任意の遷移と比べてベター)
を簡単に選べるような特徴量を設定し、常に次にベストな遷移元を用意し続け、それ以外を刈り取り続けるDP。)
-時間なしで、遷移可能な特徴だけで遷移するDP(どのような操作が行われたかを全く考えずに、
操作によって出来た操作対象の特徴(集合数や最大値、様々)を持ってきた時に、その特徴を持つものの中から
ベストなものをより小さい問題に帰着して考えることが出来るようなDP(だるま落とし))
の二種類がある。
0.1.1.ナップザックDP
　時間で遷移するDPであることが殆ど。
　操作数でループを回すのはほぼ確定なので、何を他の添字に取るのかがキモになる。
普通に添え字に状態を表すものを取ることが多いが、中には添字に値域を持って、
要素にそれぞれの値が可能かどうか判定するための数値を持って、判定問題の亜種のような形にする場合もある。
0.1.2.区間DP
　空間で遷移するDPである場合と、(だるま落とし(実際の操作については考えない))
最終操作について考えて時間で遷移するDPである場合がある。(連鎖行列積問題)
区間が操作によって広がるものであれば、遷移先を分割してより小さい問題にしていく。(メモ化再帰以外で実装するとこのタイプは事故る)
区間が操作によって狭くなるものなら、不明(解いたことがない)
0.1.3.bitDP
　時間で遷移するDPであることが多い。

bitはその状態の考慮済みの要素を表すことが殆ど。
1.動的計画法で解ける問題か判定して実装を行うまでのフローチャート
2.問題の種類とそれぞれの動的計画法との相性の詳細
3.問題の構造の種類とそれぞれの動的計画法との相性の詳細
4.実際に動的計画法で解ける問題とそれに使う動的計画法の種類