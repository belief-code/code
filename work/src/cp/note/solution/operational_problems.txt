操作系の問題に対するアプローチ
　競技プログラミングにおける解法は、その解法による最悪計算量が全探索を行った場合の計算量と比較して、
どの程度小さいか、によって評価される。このことを常に念頭において解法の評価を自分で行うと良い。
　また大きく分けると解法の手順は、
-漸化式から作るパターン(作るものはテーブルとは限らない)
-テーブルから作るパターン
の2つがある。
0.操作系問題とは
　
0.2.操作系問題での最悪計算量の下げ方
典型的なものから順に
-枝刈り探索を行う(DP,最短経路問題)
-データ構造を使う
-テーブルの更新が何らかの要因でうまくいく
枝刈りが行えるような問題は、部分構造最適性や、部分問題重複性がある問題が多い。

2.問題全体、制約、操作、求めるもの、の読み替え
　難易度の高い問題やad-hocな問題において一番の問題になりがちなのはここ。
　この読み替えによって、いいデータ構造が使用可能になって計算量が下がったり、
実装が楽になったりする。ただ読み替えと言っても高難易度の問題は読み替えを行わないとほぼ解決不能なものばかり。

2.0.問題全体の読み替えのパターン
　～を満たすように～の操作を行ったときの～を求めよ。のような問題に対して、
全てを緩めた小さな問題を解決することで、より大きな問題を解決するための情報を得られないか考える。
もしも情報を得られる場合には、良い問題の緩和を行って小さな問題から解いていくことで、
本当に求めるものを求められる場合がある。
　動的計画法などは言ってみればこれの扱いやすいパターンのようなものである。

2.0.1.ナップザック問題
　小問題に分けることが有意に働く典型例。i番目の商品までを2.の商品、W以下を1以下、
などまで緩和してそれを解いていくことがより大きい問題に繋がり最終的な目的の問題に答えられるようになる。

2.0.2.最短経路問題(原点から隣接頂点へのコスト付き移動操作を行い続け目的の頂点に辿りつくときのその最小コスト)
　最短経路上の頂点までの最短経路は、常にその頂点に原点から移動するときの最短経路になっている。
このことをヒントに、最短経路を決められる頂点に対してどんどん決めていくことが、基本的には目的の最短経路を
求めることに良い結果をもたらすことが大半である。このような背景で、小問題として、
-可能な限り少ない計算量で何かしら新しい頂点に対して最短経路を求める
を設定して、この小問題を目的の頂点に達するまで解き続ける。
と読み替えるとうまくいくことが多い。
例:ダイクストラ法、ベルマンフォード法


2.1.制約の読み替えのパターン

2.1.1.~を満たす操作の個数を求めよ系
　
例:https://atcoder.jp/contests/abc209/tasks/abc209_f

2.2.操作の読み替えのパターン

2.3.求めるものの読み替えのパターン
　

2.3.1.テーブル状のデータが求められない系
　｢Aを求めよ｣という問題を｢Aを含むテーブル全体を求めよ｣や｢Aを求めるためのデータが得られるテーブルを求めよ｣
といった問題に読み替えることで、テーブル状のデータが求められる系問題特有のアプローチが可能になる。
　特に大切なのは、直接的に枝刈り的裏付けが見えないような更新手順によって計算量が魔法のように下がるケースがあることで、
これは普通のナップザック問題などに対するものとは違うパターンで、特にこのパターンにおいては、
｢漸化式よりも先に、有り得そうなテーブルを考え計算量削減になるような手順がないか考えていく｣ことが大切になる。
　テーブル状のデータを求めることに変えるってだけだと、それナップザック問題でもやりますよね？みたいな気持ちになるけど
ナップザック問題では漸化式からの要請からテーブルを作ることになるが、ここで言っていることは、
｢テーブルを漸化式よりも先に作ってみてからしか辿り着きづらい解法が存在する。｣ということ。
例:最短経路問題のアルゴリズムは全部これって言ってもいい。(最短経路問題はその部分最適性により本質的にはテーブルが先に要請される。
これはある種の読み替えである)あと難しい問題は結構ここに入ったりする。




2.どの段階で操作を分けるか
　基本的には実際に行う操作の単位で区切って段階分けを行うが、まとまった操作で段階分けを行うことで、
累積和などが使えて計算量が落ちたり、実装がシンプルになったりする。
例:累積和が使えるパターン:https://atcoder.jp/contests/joi202.yo/tasks/joi2017yo_d



3.考える切り口とその先の解法
　以下では、最善な読み替えを行った後の問題(もしくは小問題)について、愚直な実装では間に合わない場合のみを考える。
一般的な切り口としては
-初形
-初操作
-最終操作
-最終形


3.2.初形から考える

3.2.初めの操作から順番に考える
　最も一般的な方法なので当然最初に検討したほうがいい。3回目の操作位まではシミュレーションしてみると、
かなり方針が見えやすくなるので、費用対効果激高だしとりあえずやるべき。

3.2.0.初めの操作から順番に考える時の、より詳細な考察方法と実装方法

3.2.2.各操作段階において、他の任意の操作よりも一概に良い操作が存在するかどうか考える
　概要:高難度の問題においては特に、そんなものが存在する訳ないよな～って考慮しないパターンだったりするから、
ちゃんと一回は考慮すべき。
　判定:虱潰しに操作を考えていって何かしらの操作が他の全ての操作よりも一概に良いか単純に確かめていく。
実際には、虱潰しに操作を考える必要はなく(そんな時間はない)、操作を分類してその分類の際の特徴を持つ操作の代表間で確かめる。
　実装:もしも存在するならば、そのような操作をループを使って順番に行っていけばいいだけ。
貪欲法などはここからアプローチされることが多い(と思う)。
例:https://atcoder.jp/contests/abc2.4/tasks/abc134_e
例:適当な最短経路を最小計算量で確定させる。という小問題において、特定の状態(小問題を解決してきた状態)での最短経路候補の中で最も短いものが、
それ以上の値を持つ候補経路を通った場合よりも一概に短い経路となることから最短経路たりうることがわかるので、
なんと一手でこの問題は解決可能。非負辺グラフの最短経路問題は大体この考えのもと解ける:https://atcoder.jp/contests/joi202.yo/tasks/joi2014yo_e

3.2.2.各操作段階において、下位互換的,上位互換的な操作が存在するか考える
　概要:もしも存在するなら、上位下位を考える元になる特徴量でパターンを分けて、各段階における上位互換的操作(代表値)
のみを記録して遷移を進めることで枝刈り的に探索出来るようになってかなりの計算量改善になる。
ここでの特徴量を数値の組として表したものを耳DPといったりする(らしい)。
　判定:特徴量については、操作を行う時に必要な情報を特徴量として考えると、実装の面でも良いし、
そもそも上に｢上位下位を考える元になる特徴量｣と書いてあるが、上位下位は後の操作段階で判定されることが殆どなので、
｢操作段階で必要最低限の特徴別の情報｣の文脈で使われる特徴と｢上位下位を考える元になる特徴量｣の文脈で使われる特徴は、
殆どの場合で一致する。
　実装:数値で表した特徴量と代表値の組の集合を良いデータ構造を用いて実装してループを回しながらこれを更新すると良い。



3.3.最終操作から考える
　最終操作のパターンで場合分けしてみると、前の操作のこの特徴を持つ中の最善のみから遷移すればいいので。などとなって
実質的に枝刈りを行えて計算量を下げられる。
　操作がマージ操作で要素が減っていく系の問題では特にこの方針を疑ったほうがいい。というのも、

3.3.0.最終形から考える時の、より詳細な考察方法と実装方法

3.3.2.最終操作がどこで行われるかで場合分けすると計算量が落ちるか考える
　概要:最終操作が行われるところで場合分けすると左右の区間の代表値を参照することになるが、左右の区間の代表値についても同様に
より小さい区間の代表値を参照にすることになるので、最小区間を初期化することで枝刈り探索可能になり計算量が落ちる。
　判定:マージ系操作だと大体OK、そうでない時は試してみる。
　実装:
例:https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS2.10_B&lang=ja


3.4.最終形から考える
　操作が終わった最終形の何らかの特徴で場合分けすると、これも考慮すべき特徴量のようなものが見えてきて、
枝刈り的に解決可能になったりする。
　操作によって要素が減っていく系の問題では特にこの方針を疑ったほうがいい。

3.4.0.最終形から考える時の、より詳細な考察方法と実装方法

3.4.2.初期状態で位置kにあったものが最終操作後にどうなっているのかで場合分けする
　
例:https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2.11&lang=jp




4.テーブルの埋め方、作り方
　3.の手順を踏むとテーブルを埋める問題に変換されたりする。また3.の前に2.でテーブル問題に変えてしまう方法もある(1.3.1.参照)。
更には、ナップザック問題などの状態遷移から考えてテーブルに辿り着くような問題も、制約の異なる部分問題の答えを格納するテーブルを
先に考えて(部分問題への分割)そのテーブルを埋めることを考えても同じ実装になる。
ここではテーブルを埋めるとき、作る時の考え方について解説する。

4.2.テーブルの作り方(愚直テーブルの作り方)

4.2.テーブルの最適化(圧縮)
　テーブルの埋め方を考えるのと同時にテーブル作成を行っている場合には、
特に、何個かずつ埋めていく方針を取る場合には、重複要素が多くなりそうな場合がある。
このような場合には、重複要素が同一部分に入るようにテーブルを圧縮すると、計算量が大幅削減されたりする。
また重複が少なくても、各要素を埋める時に必要な情報が隣接要素だけでいい場合には圧縮をしても理論上テーブルを埋められるので、
少ないデータだけ持っていても良かったりする。この場合にはメモリ使用量の削減や実装が単純になったりするくらいのメリットしか
ないことが殆どだが、その少ないデータを特別なデータ構造に載せることで本質的に計算量を下げることが可能になることがあるので、
とりあえずテーブルの圧縮は出来る限り行ったほうがいい。またこれをインラインDPまたは実家DPなどという。

4.2.2.二次元から一次元への圧縮
　これが出来るのは問題に
　テーブルが二次元かつ2.(行)単位で埋めていくような場合には、隣接列の要素だけが本質的に必要な場合がある。
(これは、多くのDP問題に言えることで応用範囲が超広い。)このようなときには2.分のデータだけを持っておいて、
それを更新するような形にすると、まず確実にメモリ使用量上良い、次に実装がキレイになる場合がある、
そして最後に｢特殊なデータ構造にテーブルを載せることで計算量を下げることができる｣場合がある。


4.3.テーブルの埋め方
　テーブルの埋め方には、大きく分けて
-何個かずつ埋めていく
-全ての要素を何回か更新する

4.3.2.何個かずつ埋めていく
　これは埋め終わった部分の情報を用いて違う要素を埋める。といった場合が多い

4.3.2.全ての要素を何回か更新する
　要素数が多い時は各回の計算量を少なくしないと間に合わないのでテーブルの工夫や、各計算の工夫が必要となり
難しい場合が多い。テーブルの最適化が可能なことがこの段階でわかることもあるかも？

4.3.2.1.よくある更新がうまくいくパターン
-各更新を行う時に更新前の何らかのデータを使うことでそれとの比較程度ですむ
例:ワーシャルフロイド法

4.3.2.2.更新するテーブルをデータ構造に載せるといい場合(載せなくても特殊なデータ構造になっている場合もここ)
　これは2.元テーブルの場合に多いので、とりあえず1次元テーブルの場合について考える。また、
載せなくても特殊なデータ構造になっている場合というのはLISなどの場合のこと。

4.3.2.2.1.よく使うデータ構造
よく使われるものだと
-二分ヒープ(単調増加列もこれ)
-赤黒木
-セグメント木
-BIT
など



