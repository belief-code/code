操作系の問題に対するアプローチ
　競技プログラミングにおける解法は、その解法による最悪計算量が全探索を行った場合の計算量と比較して、
どの程度小さいか、によって評価される。このことを常に念頭において解法の評価を自分で行うべし。
0.操作系問題とは
　
0.1.操作系問題での最悪計算量の下げ方
典型的なものから順に
-枝刈り探索を行う(DP,最短経路問題)


1.問題全体、制約、操作、求めるもの、の読み替え
　難易度の高い問題やad-hocな問題において一番の問題になりがちなのはここ。
　この読み替えによって、前から順番に考えることが出来て、累積和が使用可能になって計算量が下がったり、
実装が楽になったりする。ただ読み替えと言っても高難易度の問題は読み替えを行わないとほぼ解決不能なものばかり。

1.0.問題全体の読み替えのパターン
　～を満たすように～の操作を行ったときの～を求めよ。のような問題に対して、
全てを緩めた小さな問題を解決することで、より大きな問題を解決するための情報を得られないか考える。
もしも情報を得られる場合には、良い問題の緩和を行って小さな問題から解いていくことで、
本当に求めるものを求められる場合がある。
　動的計画法などは言ってみればこれの扱いやすいパターンのようなものである。

1.0.1.ナップザック問題
　小問題に分けることが有意に働く典型例。i番目の商品までを1この商品、W以下を1以下、
などまで緩和してそれを解いていくことがより大きい問題に繋がり最終的な目的の問題に答えられるようになる。

1.0.2.最短経路問題(原点から隣接頂点へのコスト付き移動操作を行い続け目的の頂点に辿りつくときのその最小コスト)
　最短経路上の頂点までの最短経路は、常にその頂点に原点から移動するときの最短経路になっている。
このことをヒントに、最短経路を決められる頂点に対してどんどん決めていくことが、基本的には目的の最短経路を
求めることに良い結果をもたらすことが大半である。このような背景で、小問題として、
-可能な限り少ない計算量で何かしら新しい頂点に対して最短経路を求める
を設定して、この小問題を目的の頂点に達するまで解き続ける。
と読み替えるとうまくいくことが多い。



1.1.制約の読み替えのパターン

1.1.1.~を満たす操作の個数を求めよ系
　
例:https://atcoder.jp/contests/abc209/tasks/abc209_f

1.2.操作の読み替えのパターン

1.3.求めるものの読み替えのパターン



2.どの段階で操作を分けるか
　基本的には実際に行う操作の単位で区切って段階分けを行うが、まとまった操作で段階分けを行うことで、
累積和などが使えて計算量が落ちたり、実装がシンプルになったりする。
例:累積和が使えるパターン:https://atcoder.jp/contests/joi2017yo/tasks/joi2017yo_d



3.考える切り口とその先の解法
　以下では、最善な読み替えを行った後の問題(もしくは小問題)について、愚直な実装では間に合わない場合のみを考える。
一般的な切り口としては
-初形
-初操作
-最終操作
-最終形


3.1.初形から考える

3.2.初めの操作から順番に考える
　最も一般的な方法なので当然最初に検討したほうがいい。3回目の操作位まではシミュレーションしてみると、
かなり方針が見えやすくなるので、費用対効果激高だしとりあえずやるべき。

3.2.0.初めの操作から順番に考える時の、より詳細な考察方法と実装方法

3.2.1.各操作段階において、他の任意の操作よりも一概に良い操作が存在するかどうか考える
　概要:高難度の問題においては特に、そんなものが存在する訳ないよな～って考慮しないパターンだったりするから、
ちゃんと一回は考慮すべき。
　判定:虱潰しに操作を考えていって何かしらの操作が他の全ての操作よりも一概に良いか単純に確かめていく。
実際には、虱潰しに操作を考える必要はなく(そんな時間はない)、操作を分類してその分類の際の特徴を持つ操作の代表間で確かめる。
　実装:もしも存在するならば、そのような操作をループを使って順番に行っていけばいいだけ。
貪欲法などはここからアプローチされることが多い(と思う)。
例:https://atcoder.jp/contests/abc134/tasks/abc134_e
例:適当な最短経路を最小計算量で確定させる。という小問題において、特定の状態(小問題を解決してきた状態)での最短経路候補の中で最も短いものが、
それ以上の値を持つ候補経路を通った場合よりも一概に短い経路となることから最短経路たりうることがわかるので、
なんと一手でこの問題は解決可能。非負辺グラフの最短経路問題は大体この考えのもと解ける:https://atcoder.jp/contests/joi2014yo/tasks/joi2014yo_e

3.2.2.各操作段階において、下位互換的,上位互換的な操作が存在するか考える
　概要:もしも存在するなら、上位下位を考える元になる特徴量でパターンを分けて、各段階における上位互換的操作(代表値)
のみを記録して遷移を進めることで枝刈り的に探索出来るようになってかなりの計算量改善になる。
ここでの特徴量を数値の組として表したものを耳DPといったりする(らしい)。
　判定:特徴量については、操作を行う時に必要な情報を特徴量として考えると、実装の面でも良いし、
そもそも上に｢上位下位を考える元になる特徴量｣と書いてあるが、上位下位は後の操作段階で判定されることが殆どなので、
｢操作段階で必要最低限の特徴別の情報｣の文脈で使われる特徴と｢上位下位を考える元になる特徴量｣の文脈で使われる特徴は、
殆どの場合で一致する。
　実装:数値で表した特徴量と代表値の組の集合を良いデータ構造を用いて実装してループを回しながらこれを更新すると良い。



3.3.最終操作から考える
　最終操作のパターンで場合分けしてみると、前の操作のこの特徴を持つ中の最善のみから遷移すればいいので。などとなって
実質的に枝刈りを行えて計算量を下げられる。
　操作がマージ操作で要素が減っていく系の問題では特にこの方針を疑ったほうがいい。というのも、

3.3.0.最終形から考える時の、より詳細な考察方法と実装方法

3.3.1.最終操作がどこで行われるかで場合分けすると計算量が落ちるか考える
　概要:最終操作が行われるところで場合分けすると左右の区間の代表値を参照することになるが、左右の区間の代表値についても同様に
より小さい区間の代表値を参照にすることになるので、最小区間を初期化することで枝刈り探索可能になり計算量が落ちる。
　判定:マージ系操作だと大体OK、そうでない時は試してみる。
　実装:
例:https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_B&lang=ja


3.4.最終形から考える
　操作が終わった最終形の何らかの特徴で場合分けすると、これも考慮すべき特徴量のようなものが見えてきて、
枝刈り的に解決可能になったりする。
　操作によって要素が減っていく系の問題では特にこの方針を疑ったほうがいい。

3.4.0.最終形から考える時の、より詳細な考察方法と実装方法

3.4.2.初期状態で位置kにあったものが最終操作後にどうなっているのかで場合分けする
　
例:https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1611&lang=jp
