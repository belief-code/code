                探索系
　定義域について探索して、それが条件を満たすか？や、
値域について探索して、それを満たすように構成できるか？
などの解法に用いられる超一般的なアルゴリズム

            シンプルな探索系
        1.全探索
    1.1.全列挙
　考えられる全てのパターンを実際に作ってみるアルゴリズム。
計算量:O(N)
    1.2.ビット全探索
　要素の組み合わせのパターン全てを確かめたい場合に使う全探索。
計算量:O(2^N)
    1.3.順列全探索
　要素を使う順番について全てのパターン確かめたい場合に使う全探索。
計算量:O(N!)
        2.二分探索
　ある連続な番号が割り振られた集合に対して、ある判定問題について、
ある要素を境に真偽を分割できることが保証されている集合に対して使えるアルゴリズム。
計算量:O(logN)
        3.深さ優先探索(DFS)
　グラフとみなせるデータ構造に対して、隣接ノードを記録していった時に、その中の探索済みでない新しいものを優先して
探索していくアルゴリズム。主に再帰関数で実装される。
        4.幅優先探索(BFS)
　グラフとみなせるデータ構造に対して、離接ノードを記録していった時に、その中の探索済みでない古いものを優先して
探索していくアルゴリズム。主にキューを用いて実装される。

            複合型の探索系
        1.半列挙
　分割して全列挙したのち要素を満たすものを二分探索などで探すことで、
普通に全列挙するとO(n^4)掛かるものを、n^2それぞれにlog(n^2)回の探索、にすることが出来たりする。


                動的計画法
　最善操作問題

                最短経路問題
            1.単一始点全点間最短路問題
        1.ベルマンフォード法

        2.ダイクストラ法

            2.全点対間最短経路問題
        1.ワーシャルフロイド法

                最小全域木問題
            1.貪欲アルゴリズム
        1.クラスカル法

        2.プリム法

                整数問題
            1.素数
        1.素数判定のO(√n)のナイーブな実装
概要:nがある約数aを持つ時,それに対応する約数bを持つ.この関係を用いて,nが1とその数自体以外の約数を持つ時,その約数もしくはそれに対応する約数のどちらかは√n以下である.逆に√n以下に約数がないのであれば他に約数は存在し得ない(1とその数自身を除く).
このことを用いてfloor(√n)までの値のみを走査することで素数判定を行うアルゴリズムのこと.

        2.ある数以下の素数の列挙(O(nlogn))
概要:エラトステネスの篩を用いて実装する.各値について素数判定を行っていくとO(n√n)かかってしまうが,これを用いるとかなり早く列挙することが出来る.

            2.高速な素因数分解

            3.高速な冪乗計算
        1.二分累乗法
概要:指数を二進法で表し,各ビットを走査しながら1から始めて積を取っていくことで求めたい冪乗を高速に計算する手法.Pythonの冪乗計算ではデフォルトでこれが行われているらしい.

            4.逆元
概要:逆元の定義は逆数の定義と同じで,aの逆元がbである時a*b≡1(modp)が成り立つ.
        1.フェルマーの小定理を用いた逆元の計算
概要:pが素数であればa^(p-1)≡1(modp)⇔a*a^(p-2)≡1(modp)∴aの逆元はa^(p-2).このような関係を用いた逆元の計算.
これは二分累乗法などを用いることで高速に求める事ができる.



